// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mutator.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mutator_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mutator_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mutator_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mutator_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mutator_2eproto;
namespace MUTATOR {
class AuthRequest;
struct AuthRequestDefaultTypeInternal;
extern AuthRequestDefaultTypeInternal _AuthRequest_default_instance_;
class CallbackResponse;
struct CallbackResponseDefaultTypeInternal;
extern CallbackResponseDefaultTypeInternal _CallbackResponse_default_instance_;
class ExpireCallback;
struct ExpireCallbackDefaultTypeInternal;
extern ExpireCallbackDefaultTypeInternal _ExpireCallback_default_instance_;
class ExportCallback;
struct ExportCallbackDefaultTypeInternal;
extern ExportCallbackDefaultTypeInternal _ExportCallback_default_instance_;
class ImportedModule;
struct ImportedModuleDefaultTypeInternal;
extern ImportedModuleDefaultTypeInternal _ImportedModule_default_instance_;
class ImportedModule_FunctionsEntry_DoNotUse;
struct ImportedModule_FunctionsEntry_DoNotUseDefaultTypeInternal;
extern ImportedModule_FunctionsEntry_DoNotUseDefaultTypeInternal _ImportedModule_FunctionsEntry_DoNotUse_default_instance_;
class InitializationRequest;
struct InitializationRequestDefaultTypeInternal;
extern InitializationRequestDefaultTypeInternal _InitializationRequest_default_instance_;
class InstanceRequest;
struct InstanceRequestDefaultTypeInternal;
extern InstanceRequestDefaultTypeInternal _InstanceRequest_default_instance_;
class LaunchData;
struct LaunchDataDefaultTypeInternal;
extern LaunchDataDefaultTypeInternal _LaunchData_default_instance_;
class MapperData;
struct MapperDataDefaultTypeInternal;
extern MapperDataDefaultTypeInternal _MapperData_default_instance_;
class MapperData_ImportsEntry_DoNotUse;
struct MapperData_ImportsEntry_DoNotUseDefaultTypeInternal;
extern MapperData_ImportsEntry_DoNotUseDefaultTypeInternal _MapperData_ImportsEntry_DoNotUse_default_instance_;
class MutatorRequest;
struct MutatorRequestDefaultTypeInternal;
extern MutatorRequestDefaultTypeInternal _MutatorRequest_default_instance_;
class MutatorRequest_ImportsEntry_DoNotUse;
struct MutatorRequest_ImportsEntry_DoNotUseDefaultTypeInternal;
extern MutatorRequest_ImportsEntry_DoNotUseDefaultTypeInternal _MutatorRequest_ImportsEntry_DoNotUse_default_instance_;
class MutatorSettings;
struct MutatorSettingsDefaultTypeInternal;
extern MutatorSettingsDefaultTypeInternal _MutatorSettings_default_instance_;
class ServerResponse;
struct ServerResponseDefaultTypeInternal;
extern ServerResponseDefaultTypeInternal _ServerResponse_default_instance_;
class VersionUpdateCallback;
struct VersionUpdateCallbackDefaultTypeInternal;
extern VersionUpdateCallbackDefaultTypeInternal _VersionUpdateCallback_default_instance_;
}  // namespace MUTATOR
PROTOBUF_NAMESPACE_OPEN
template<> ::MUTATOR::AuthRequest* Arena::CreateMaybeMessage<::MUTATOR::AuthRequest>(Arena*);
template<> ::MUTATOR::CallbackResponse* Arena::CreateMaybeMessage<::MUTATOR::CallbackResponse>(Arena*);
template<> ::MUTATOR::ExpireCallback* Arena::CreateMaybeMessage<::MUTATOR::ExpireCallback>(Arena*);
template<> ::MUTATOR::ExportCallback* Arena::CreateMaybeMessage<::MUTATOR::ExportCallback>(Arena*);
template<> ::MUTATOR::ImportedModule* Arena::CreateMaybeMessage<::MUTATOR::ImportedModule>(Arena*);
template<> ::MUTATOR::ImportedModule_FunctionsEntry_DoNotUse* Arena::CreateMaybeMessage<::MUTATOR::ImportedModule_FunctionsEntry_DoNotUse>(Arena*);
template<> ::MUTATOR::InitializationRequest* Arena::CreateMaybeMessage<::MUTATOR::InitializationRequest>(Arena*);
template<> ::MUTATOR::InstanceRequest* Arena::CreateMaybeMessage<::MUTATOR::InstanceRequest>(Arena*);
template<> ::MUTATOR::LaunchData* Arena::CreateMaybeMessage<::MUTATOR::LaunchData>(Arena*);
template<> ::MUTATOR::MapperData* Arena::CreateMaybeMessage<::MUTATOR::MapperData>(Arena*);
template<> ::MUTATOR::MapperData_ImportsEntry_DoNotUse* Arena::CreateMaybeMessage<::MUTATOR::MapperData_ImportsEntry_DoNotUse>(Arena*);
template<> ::MUTATOR::MutatorRequest* Arena::CreateMaybeMessage<::MUTATOR::MutatorRequest>(Arena*);
template<> ::MUTATOR::MutatorRequest_ImportsEntry_DoNotUse* Arena::CreateMaybeMessage<::MUTATOR::MutatorRequest_ImportsEntry_DoNotUse>(Arena*);
template<> ::MUTATOR::MutatorSettings* Arena::CreateMaybeMessage<::MUTATOR::MutatorSettings>(Arena*);
template<> ::MUTATOR::ServerResponse* Arena::CreateMaybeMessage<::MUTATOR::ServerResponse>(Arena*);
template<> ::MUTATOR::VersionUpdateCallback* Arena::CreateMaybeMessage<::MUTATOR::VersionUpdateCallback>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace MUTATOR {

enum VM : int {
  VM_NONE = 0,
  VM_OREANS = 1,
  VM_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VM_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VM_IsValid(int value);
constexpr VM VM_MIN = VM_NONE;
constexpr VM VM_MAX = VM_OREANS;
constexpr int VM_ARRAYSIZE = VM_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VM_descriptor();
template<typename T>
inline const std::string& VM_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VM>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VM_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VM_descriptor(), enum_t_value);
}
inline bool VM_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VM* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VM>(
    VM_descriptor(), name, value);
}
enum Callback : int {
  CALLBACK_NONE = 0,
  CALLBACK_EXPORT_INIT = 1,
  CALLBACK_EXPORT_MMAP = 2,
  CALLBACK_SUBSCRIPTION_EXPIRE = 3,
  CALLBACK_VERSION_UPDATE = 4,
  CALLBACK_RESERVED = 5,
  Callback_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Callback_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Callback_IsValid(int value);
constexpr Callback Callback_MIN = CALLBACK_NONE;
constexpr Callback Callback_MAX = CALLBACK_RESERVED;
constexpr int Callback_ARRAYSIZE = Callback_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Callback_descriptor();
template<typename T>
inline const std::string& Callback_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Callback>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Callback_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Callback_descriptor(), enum_t_value);
}
inline bool Callback_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Callback* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Callback>(
    Callback_descriptor(), name, value);
}
// ===================================================================

class AuthRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MUTATOR.AuthRequest) */ {
 public:
  inline AuthRequest() : AuthRequest(nullptr) {}
  ~AuthRequest() override;
  explicit constexpr AuthRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRequest(const AuthRequest& from);
  AuthRequest(AuthRequest&& from) noexcept
    : AuthRequest() {
    *this = ::std::move(from);
  }

  inline AuthRequest& operator=(const AuthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRequest& operator=(AuthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRequest* internal_default_instance() {
    return reinterpret_cast<const AuthRequest*>(
               &_AuthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AuthRequest& a, AuthRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MUTATOR.AuthRequest";
  }
  protected:
  explicit AuthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthTokenFieldNumber = 1,
  };
  // string auth_token = 1;
  void clear_auth_token();
  const std::string& auth_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_token();
  PROTOBUF_NODISCARD std::string* release_auth_token();
  void set_allocated_auth_token(std::string* auth_token);
  private:
  const std::string& _internal_auth_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_token(const std::string& value);
  std::string* _internal_mutable_auth_token();
  public:

  // @@protoc_insertion_point(class_scope:MUTATOR.AuthRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mutator_2eproto;
};
// -------------------------------------------------------------------

class MutatorSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MUTATOR.MutatorSettings) */ {
 public:
  inline MutatorSettings() : MutatorSettings(nullptr) {}
  ~MutatorSettings() override;
  explicit constexpr MutatorSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MutatorSettings(const MutatorSettings& from);
  MutatorSettings(MutatorSettings&& from) noexcept
    : MutatorSettings() {
    *this = ::std::move(from);
  }

  inline MutatorSettings& operator=(const MutatorSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutatorSettings& operator=(MutatorSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MutatorSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const MutatorSettings* internal_default_instance() {
    return reinterpret_cast<const MutatorSettings*>(
               &_MutatorSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MutatorSettings& a, MutatorSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(MutatorSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MutatorSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MutatorSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MutatorSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MutatorSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MutatorSettings& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutatorSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MUTATOR.MutatorSettings";
  }
  protected:
  explicit MutatorSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallbacksFieldNumber = 10,
    kShuffleFieldNumber = 1,
    kBlockAsObjectFieldNumber = 2,
    kBlockShuffleFieldNumber = 3,
    kObfuscateRttiFieldNumber = 4,
    kPartitionFieldNumber = 5,
    kSectionRandomizationFieldNumber = 6,
    kMinMutationLengthFieldNumber = 7,
    kMaxMutationLengthFieldNumber = 8,
    kVmTypeFieldNumber = 9,
  };
  // repeated .MUTATOR.Callback callbacks = 10;
  int callbacks_size() const;
  private:
  int _internal_callbacks_size() const;
  public:
  void clear_callbacks();
  private:
  ::MUTATOR::Callback _internal_callbacks(int index) const;
  void _internal_add_callbacks(::MUTATOR::Callback value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_callbacks();
  public:
  ::MUTATOR::Callback callbacks(int index) const;
  void set_callbacks(int index, ::MUTATOR::Callback value);
  void add_callbacks(::MUTATOR::Callback value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& callbacks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_callbacks();

  // optional bool shuffle = 1;
  bool has_shuffle() const;
  private:
  bool _internal_has_shuffle() const;
  public:
  void clear_shuffle();
  bool shuffle() const;
  void set_shuffle(bool value);
  private:
  bool _internal_shuffle() const;
  void _internal_set_shuffle(bool value);
  public:

  // optional bool block_as_object = 2;
  bool has_block_as_object() const;
  private:
  bool _internal_has_block_as_object() const;
  public:
  void clear_block_as_object();
  bool block_as_object() const;
  void set_block_as_object(bool value);
  private:
  bool _internal_block_as_object() const;
  void _internal_set_block_as_object(bool value);
  public:

  // optional bool block_shuffle = 3;
  bool has_block_shuffle() const;
  private:
  bool _internal_has_block_shuffle() const;
  public:
  void clear_block_shuffle();
  bool block_shuffle() const;
  void set_block_shuffle(bool value);
  private:
  bool _internal_block_shuffle() const;
  void _internal_set_block_shuffle(bool value);
  public:

  // optional bool obfuscate_rtti = 4;
  bool has_obfuscate_rtti() const;
  private:
  bool _internal_has_obfuscate_rtti() const;
  public:
  void clear_obfuscate_rtti();
  bool obfuscate_rtti() const;
  void set_obfuscate_rtti(bool value);
  private:
  bool _internal_obfuscate_rtti() const;
  void _internal_set_obfuscate_rtti(bool value);
  public:

  // optional bool partition = 5;
  bool has_partition() const;
  private:
  bool _internal_has_partition() const;
  public:
  void clear_partition();
  bool partition() const;
  void set_partition(bool value);
  private:
  bool _internal_partition() const;
  void _internal_set_partition(bool value);
  public:

  // optional bool section_randomization = 6;
  bool has_section_randomization() const;
  private:
  bool _internal_has_section_randomization() const;
  public:
  void clear_section_randomization();
  bool section_randomization() const;
  void set_section_randomization(bool value);
  private:
  bool _internal_section_randomization() const;
  void _internal_set_section_randomization(bool value);
  public:

  // optional uint32 min_mutation_length = 7;
  bool has_min_mutation_length() const;
  private:
  bool _internal_has_min_mutation_length() const;
  public:
  void clear_min_mutation_length();
  uint32_t min_mutation_length() const;
  void set_min_mutation_length(uint32_t value);
  private:
  uint32_t _internal_min_mutation_length() const;
  void _internal_set_min_mutation_length(uint32_t value);
  public:

  // optional uint32 max_mutation_length = 8;
  bool has_max_mutation_length() const;
  private:
  bool _internal_has_max_mutation_length() const;
  public:
  void clear_max_mutation_length();
  uint32_t max_mutation_length() const;
  void set_max_mutation_length(uint32_t value);
  private:
  uint32_t _internal_max_mutation_length() const;
  void _internal_set_max_mutation_length(uint32_t value);
  public:

  // optional .MUTATOR.VM vm_type = 9;
  bool has_vm_type() const;
  private:
  bool _internal_has_vm_type() const;
  public:
  void clear_vm_type();
  ::MUTATOR::VM vm_type() const;
  void set_vm_type(::MUTATOR::VM value);
  private:
  ::MUTATOR::VM _internal_vm_type() const;
  void _internal_set_vm_type(::MUTATOR::VM value);
  public:

  // @@protoc_insertion_point(class_scope:MUTATOR.MutatorSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> callbacks_;
  mutable std::atomic<int> _callbacks_cached_byte_size_;
  bool shuffle_;
  bool block_as_object_;
  bool block_shuffle_;
  bool obfuscate_rtti_;
  bool partition_;
  bool section_randomization_;
  uint32_t min_mutation_length_;
  uint32_t max_mutation_length_;
  int vm_type_;
  friend struct ::TableStruct_mutator_2eproto;
};
// -------------------------------------------------------------------

class InitializationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MUTATOR.InitializationRequest) */ {
 public:
  inline InitializationRequest() : InitializationRequest(nullptr) {}
  ~InitializationRequest() override;
  explicit constexpr InitializationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitializationRequest(const InitializationRequest& from);
  InitializationRequest(InitializationRequest&& from) noexcept
    : InitializationRequest() {
    *this = ::std::move(from);
  }

  inline InitializationRequest& operator=(const InitializationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitializationRequest& operator=(InitializationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitializationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitializationRequest* internal_default_instance() {
    return reinterpret_cast<const InitializationRequest*>(
               &_InitializationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InitializationRequest& a, InitializationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitializationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitializationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitializationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitializationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitializationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InitializationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MUTATOR.InitializationRequest";
  }
  protected:
  explicit InitializationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinaryFieldNumber = 1,
    kSymbolsFieldNumber = 2,
    kProtectedBinaryFieldNumber = 3,
    kSettingsFieldNumber = 4,
  };
  // bytes binary = 1;
  void clear_binary();
  const std::string& binary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binary();
  PROTOBUF_NODISCARD std::string* release_binary();
  void set_allocated_binary(std::string* binary);
  private:
  const std::string& _internal_binary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary(const std::string& value);
  std::string* _internal_mutable_binary();
  public:

  // bytes symbols = 2;
  void clear_symbols();
  const std::string& symbols() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbols(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbols();
  PROTOBUF_NODISCARD std::string* release_symbols();
  void set_allocated_symbols(std::string* symbols);
  private:
  const std::string& _internal_symbols() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbols(const std::string& value);
  std::string* _internal_mutable_symbols();
  public:

  // optional bytes protected_binary = 3;
  bool has_protected_binary() const;
  private:
  bool _internal_has_protected_binary() const;
  public:
  void clear_protected_binary();
  const std::string& protected_binary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_protected_binary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_protected_binary();
  PROTOBUF_NODISCARD std::string* release_protected_binary();
  void set_allocated_protected_binary(std::string* protected_binary);
  private:
  const std::string& _internal_protected_binary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_protected_binary(const std::string& value);
  std::string* _internal_mutable_protected_binary();
  public:

  // optional .MUTATOR.MutatorSettings settings = 4;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::MUTATOR::MutatorSettings& settings() const;
  PROTOBUF_NODISCARD ::MUTATOR::MutatorSettings* release_settings();
  ::MUTATOR::MutatorSettings* mutable_settings();
  void set_allocated_settings(::MUTATOR::MutatorSettings* settings);
  private:
  const ::MUTATOR::MutatorSettings& _internal_settings() const;
  ::MUTATOR::MutatorSettings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::MUTATOR::MutatorSettings* settings);
  ::MUTATOR::MutatorSettings* unsafe_arena_release_settings();

  // @@protoc_insertion_point(class_scope:MUTATOR.InitializationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbols_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protected_binary_;
  ::MUTATOR::MutatorSettings* settings_;
  friend struct ::TableStruct_mutator_2eproto;
};
// -------------------------------------------------------------------

class ImportedModule_FunctionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ImportedModule_FunctionsEntry_DoNotUse, 
    std::string, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ImportedModule_FunctionsEntry_DoNotUse, 
    std::string, uint64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> SuperType;
  ImportedModule_FunctionsEntry_DoNotUse();
  explicit constexpr ImportedModule_FunctionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ImportedModule_FunctionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ImportedModule_FunctionsEntry_DoNotUse& other);
  static const ImportedModule_FunctionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ImportedModule_FunctionsEntry_DoNotUse*>(&_ImportedModule_FunctionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "MUTATOR.ImportedModule.FunctionsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ImportedModule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MUTATOR.ImportedModule) */ {
 public:
  inline ImportedModule() : ImportedModule(nullptr) {}
  ~ImportedModule() override;
  explicit constexpr ImportedModule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImportedModule(const ImportedModule& from);
  ImportedModule(ImportedModule&& from) noexcept
    : ImportedModule() {
    *this = ::std::move(from);
  }

  inline ImportedModule& operator=(const ImportedModule& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImportedModule& operator=(ImportedModule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImportedModule& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImportedModule* internal_default_instance() {
    return reinterpret_cast<const ImportedModule*>(
               &_ImportedModule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ImportedModule& a, ImportedModule& b) {
    a.Swap(&b);
  }
  inline void Swap(ImportedModule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImportedModule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImportedModule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImportedModule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImportedModule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImportedModule& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportedModule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MUTATOR.ImportedModule";
  }
  protected:
  explicit ImportedModule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFunctionsFieldNumber = 2,
  };
  // map<string, uint64> functions = 2;
  int functions_size() const;
  private:
  int _internal_functions_size() const;
  public:
  void clear_functions();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
      _internal_functions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
      _internal_mutable_functions();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
      functions() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
      mutable_functions();

  // @@protoc_insertion_point(class_scope:MUTATOR.ImportedModule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ImportedModule_FunctionsEntry_DoNotUse,
      std::string, uint64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64> functions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mutator_2eproto;
};
// -------------------------------------------------------------------

class MapperData_ImportsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MapperData_ImportsEntry_DoNotUse, 
    std::string, ::MUTATOR::ImportedModule,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MapperData_ImportsEntry_DoNotUse, 
    std::string, ::MUTATOR::ImportedModule,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  MapperData_ImportsEntry_DoNotUse();
  explicit constexpr MapperData_ImportsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit MapperData_ImportsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MapperData_ImportsEntry_DoNotUse& other);
  static const MapperData_ImportsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapperData_ImportsEntry_DoNotUse*>(&_MapperData_ImportsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "MUTATOR.MapperData.ImportsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class MapperData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MUTATOR.MapperData) */ {
 public:
  inline MapperData() : MapperData(nullptr) {}
  ~MapperData() override;
  explicit constexpr MapperData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapperData(const MapperData& from);
  MapperData(MapperData&& from) noexcept
    : MapperData() {
    *this = ::std::move(from);
  }

  inline MapperData& operator=(const MapperData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapperData& operator=(MapperData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapperData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapperData* internal_default_instance() {
    return reinterpret_cast<const MapperData*>(
               &_MapperData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MapperData& a, MapperData& b) {
    a.Swap(&b);
  }
  inline void Swap(MapperData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapperData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapperData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapperData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MapperData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MapperData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapperData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MUTATOR.MapperData";
  }
  protected:
  explicit MapperData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSizesFieldNumber = 1,
    kImportsFieldNumber = 2,
  };
  // repeated uint32 sizes = 1;
  int sizes_size() const;
  private:
  int _internal_sizes_size() const;
  public:
  void clear_sizes();
  private:
  uint32_t _internal_sizes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_sizes() const;
  void _internal_add_sizes(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_sizes();
  public:
  uint32_t sizes(int index) const;
  void set_sizes(int index, uint32_t value);
  void add_sizes(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      sizes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_sizes();

  // map<string, .MUTATOR.ImportedModule> imports = 2;
  int imports_size() const;
  private:
  int _internal_imports_size() const;
  public:
  void clear_imports();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >&
      _internal_imports() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >*
      _internal_mutable_imports();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >&
      imports() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >*
      mutable_imports();

  // @@protoc_insertion_point(class_scope:MUTATOR.MapperData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > sizes_;
  mutable std::atomic<int> _sizes_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MapperData_ImportsEntry_DoNotUse,
      std::string, ::MUTATOR::ImportedModule,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> imports_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mutator_2eproto;
};
// -------------------------------------------------------------------

class LaunchData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MUTATOR.LaunchData) */ {
 public:
  inline LaunchData() : LaunchData(nullptr) {}
  ~LaunchData() override;
  explicit constexpr LaunchData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LaunchData(const LaunchData& from);
  LaunchData(LaunchData&& from) noexcept
    : LaunchData() {
    *this = ::std::move(from);
  }

  inline LaunchData& operator=(const LaunchData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaunchData& operator=(LaunchData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaunchData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaunchData* internal_default_instance() {
    return reinterpret_cast<const LaunchData*>(
               &_LaunchData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LaunchData& a, LaunchData& b) {
    a.Swap(&b);
  }
  inline void Swap(LaunchData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaunchData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaunchData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaunchData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LaunchData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LaunchData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaunchData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MUTATOR.LaunchData";
  }
  protected:
  explicit LaunchData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallablesFieldNumber = 2,
    kEntryFieldNumber = 1,
  };
  // repeated uint64 callables = 2;
  int callables_size() const;
  private:
  int _internal_callables_size() const;
  public:
  void clear_callables();
  private:
  uint64_t _internal_callables(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_callables() const;
  void _internal_add_callables(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_callables();
  public:
  uint64_t callables(int index) const;
  void set_callables(int index, uint64_t value);
  void add_callables(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      callables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_callables();

  // optional uint64 entry = 1;
  bool has_entry() const;
  private:
  bool _internal_has_entry() const;
  public:
  void clear_entry();
  uint64_t entry() const;
  void set_entry(uint64_t value);
  private:
  uint64_t _internal_entry() const;
  void _internal_set_entry(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:MUTATOR.LaunchData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > callables_;
  mutable std::atomic<int> _callables_cached_byte_size_;
  uint64_t entry_;
  friend struct ::TableStruct_mutator_2eproto;
};
// -------------------------------------------------------------------

class ExportCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MUTATOR.ExportCallback) */ {
 public:
  inline ExportCallback() : ExportCallback(nullptr) {}
  ~ExportCallback() override;
  explicit constexpr ExportCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExportCallback(const ExportCallback& from);
  ExportCallback(ExportCallback&& from) noexcept
    : ExportCallback() {
    *this = ::std::move(from);
  }

  inline ExportCallback& operator=(const ExportCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportCallback& operator=(ExportCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportCallback* internal_default_instance() {
    return reinterpret_cast<const ExportCallback*>(
               &_ExportCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ExportCallback& a, ExportCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExportCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExportCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExportCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExportCallback& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExportCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MUTATOR.ExportCallback";
  }
  protected:
  explicit ExportCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 3,
    kSizeFieldNumber = 2,
    kIsConstFieldNumber = 4,
    kIsCallableFieldNumber = 5,
    kUniqueIdFieldNumber = 6,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bytes value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional uint32 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // optional bool is_const = 4;
  bool has_is_const() const;
  private:
  bool _internal_has_is_const() const;
  public:
  void clear_is_const();
  bool is_const() const;
  void set_is_const(bool value);
  private:
  bool _internal_is_const() const;
  void _internal_set_is_const(bool value);
  public:

  // optional bool is_callable = 5;
  bool has_is_callable() const;
  private:
  bool _internal_has_is_callable() const;
  public:
  void clear_is_callable();
  bool is_callable() const;
  void set_is_callable(bool value);
  private:
  bool _internal_is_callable() const;
  void _internal_set_is_callable(bool value);
  public:

  // optional uint32 unique_id = 6;
  bool has_unique_id() const;
  private:
  bool _internal_has_unique_id() const;
  public:
  void clear_unique_id();
  uint32_t unique_id() const;
  void set_unique_id(uint32_t value);
  private:
  uint32_t _internal_unique_id() const;
  void _internal_set_unique_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MUTATOR.ExportCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  uint32_t size_;
  bool is_const_;
  bool is_callable_;
  uint32_t unique_id_;
  friend struct ::TableStruct_mutator_2eproto;
};
// -------------------------------------------------------------------

class ExpireCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MUTATOR.ExpireCallback) */ {
 public:
  inline ExpireCallback() : ExpireCallback(nullptr) {}
  ~ExpireCallback() override;
  explicit constexpr ExpireCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExpireCallback(const ExpireCallback& from);
  ExpireCallback(ExpireCallback&& from) noexcept
    : ExpireCallback() {
    *this = ::std::move(from);
  }

  inline ExpireCallback& operator=(const ExpireCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExpireCallback& operator=(ExpireCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExpireCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExpireCallback* internal_default_instance() {
    return reinterpret_cast<const ExpireCallback*>(
               &_ExpireCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ExpireCallback& a, ExpireCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(ExpireCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExpireCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExpireCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExpireCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExpireCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExpireCallback& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpireCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MUTATOR.ExpireCallback";
  }
  protected:
  explicit ExpireCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeLeftFieldNumber = 1,
  };
  // optional uint64 time_left = 1;
  bool has_time_left() const;
  private:
  bool _internal_has_time_left() const;
  public:
  void clear_time_left();
  uint64_t time_left() const;
  void set_time_left(uint64_t value);
  private:
  uint64_t _internal_time_left() const;
  void _internal_set_time_left(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:MUTATOR.ExpireCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t time_left_;
  friend struct ::TableStruct_mutator_2eproto;
};
// -------------------------------------------------------------------

class VersionUpdateCallback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MUTATOR.VersionUpdateCallback) */ {
 public:
  inline VersionUpdateCallback() : VersionUpdateCallback(nullptr) {}
  ~VersionUpdateCallback() override;
  explicit constexpr VersionUpdateCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VersionUpdateCallback(const VersionUpdateCallback& from);
  VersionUpdateCallback(VersionUpdateCallback&& from) noexcept
    : VersionUpdateCallback() {
    *this = ::std::move(from);
  }

  inline VersionUpdateCallback& operator=(const VersionUpdateCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionUpdateCallback& operator=(VersionUpdateCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VersionUpdateCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const VersionUpdateCallback* internal_default_instance() {
    return reinterpret_cast<const VersionUpdateCallback*>(
               &_VersionUpdateCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(VersionUpdateCallback& a, VersionUpdateCallback& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionUpdateCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionUpdateCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VersionUpdateCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VersionUpdateCallback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VersionUpdateCallback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VersionUpdateCallback& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionUpdateCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MUTATOR.VersionUpdateCallback";
  }
  protected:
  explicit VersionUpdateCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // optional string version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:MUTATOR.VersionUpdateCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  friend struct ::TableStruct_mutator_2eproto;
};
// -------------------------------------------------------------------

class CallbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MUTATOR.CallbackResponse) */ {
 public:
  inline CallbackResponse() : CallbackResponse(nullptr) {}
  ~CallbackResponse() override;
  explicit constexpr CallbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallbackResponse(const CallbackResponse& from);
  CallbackResponse(CallbackResponse&& from) noexcept
    : CallbackResponse() {
    *this = ::std::move(from);
  }

  inline CallbackResponse& operator=(const CallbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallbackResponse& operator=(CallbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallbackResponse* internal_default_instance() {
    return reinterpret_cast<const CallbackResponse*>(
               &_CallbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CallbackResponse& a, CallbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CallbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CallbackResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MUTATOR.CallbackResponse";
  }
  protected:
  explicit CallbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExportFieldNumber = 2,
    kExpireFieldNumber = 3,
    kVersionFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // optional .MUTATOR.ExportCallback export = 2;
  bool has_export_() const;
  private:
  bool _internal_has_export_() const;
  public:
  void clear_export_();
  const ::MUTATOR::ExportCallback& export_() const;
  PROTOBUF_NODISCARD ::MUTATOR::ExportCallback* release_export_();
  ::MUTATOR::ExportCallback* mutable_export_();
  void set_allocated_export_(::MUTATOR::ExportCallback* export_);
  private:
  const ::MUTATOR::ExportCallback& _internal_export_() const;
  ::MUTATOR::ExportCallback* _internal_mutable_export_();
  public:
  void unsafe_arena_set_allocated_export_(
      ::MUTATOR::ExportCallback* export_);
  ::MUTATOR::ExportCallback* unsafe_arena_release_export_();

  // optional .MUTATOR.ExpireCallback expire = 3;
  bool has_expire() const;
  private:
  bool _internal_has_expire() const;
  public:
  void clear_expire();
  const ::MUTATOR::ExpireCallback& expire() const;
  PROTOBUF_NODISCARD ::MUTATOR::ExpireCallback* release_expire();
  ::MUTATOR::ExpireCallback* mutable_expire();
  void set_allocated_expire(::MUTATOR::ExpireCallback* expire);
  private:
  const ::MUTATOR::ExpireCallback& _internal_expire() const;
  ::MUTATOR::ExpireCallback* _internal_mutable_expire();
  public:
  void unsafe_arena_set_allocated_expire(
      ::MUTATOR::ExpireCallback* expire);
  ::MUTATOR::ExpireCallback* unsafe_arena_release_expire();

  // optional .MUTATOR.VersionUpdateCallback version = 4;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::MUTATOR::VersionUpdateCallback& version() const;
  PROTOBUF_NODISCARD ::MUTATOR::VersionUpdateCallback* release_version();
  ::MUTATOR::VersionUpdateCallback* mutable_version();
  void set_allocated_version(::MUTATOR::VersionUpdateCallback* version);
  private:
  const ::MUTATOR::VersionUpdateCallback& _internal_version() const;
  ::MUTATOR::VersionUpdateCallback* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::MUTATOR::VersionUpdateCallback* version);
  ::MUTATOR::VersionUpdateCallback* unsafe_arena_release_version();

  // optional .MUTATOR.Callback type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::MUTATOR::Callback type() const;
  void set_type(::MUTATOR::Callback value);
  private:
  ::MUTATOR::Callback _internal_type() const;
  void _internal_set_type(::MUTATOR::Callback value);
  public:

  // @@protoc_insertion_point(class_scope:MUTATOR.CallbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::MUTATOR::ExportCallback* export__;
  ::MUTATOR::ExpireCallback* expire_;
  ::MUTATOR::VersionUpdateCallback* version_;
  int type_;
  friend struct ::TableStruct_mutator_2eproto;
};
// -------------------------------------------------------------------

class ServerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MUTATOR.ServerResponse) */ {
 public:
  inline ServerResponse() : ServerResponse(nullptr) {}
  ~ServerResponse() override;
  explicit constexpr ServerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerResponse(const ServerResponse& from);
  ServerResponse(ServerResponse&& from) noexcept
    : ServerResponse() {
    *this = ::std::move(from);
  }

  inline ServerResponse& operator=(const ServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerResponse& operator=(ServerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerResponse* internal_default_instance() {
    return reinterpret_cast<const ServerResponse*>(
               &_ServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ServerResponse& a, ServerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MUTATOR.ServerResponse";
  }
  protected:
  explicit ServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinariesFieldNumber = 5,
    kTokenFieldNumber = 1,
    kMapperDataFieldNumber = 6,
    kLaunchDataFieldNumber = 7,
    kCallbackFieldNumber = 8,
    kTypeFieldNumber = 2,
    kStatusFieldNumber = 3,
    kSessionIdFieldNumber = 4,
  };
  // repeated bytes binaries = 5;
  int binaries_size() const;
  private:
  int _internal_binaries_size() const;
  public:
  void clear_binaries();
  const std::string& binaries(int index) const;
  std::string* mutable_binaries(int index);
  void set_binaries(int index, const std::string& value);
  void set_binaries(int index, std::string&& value);
  void set_binaries(int index, const char* value);
  void set_binaries(int index, const void* value, size_t size);
  std::string* add_binaries();
  void add_binaries(const std::string& value);
  void add_binaries(std::string&& value);
  void add_binaries(const char* value);
  void add_binaries(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& binaries() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_binaries();
  private:
  const std::string& _internal_binaries(int index) const;
  std::string* _internal_add_binaries();
  public:

  // optional string token = 1;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional .MUTATOR.MapperData mapperData = 6;
  bool has_mapperdata() const;
  private:
  bool _internal_has_mapperdata() const;
  public:
  void clear_mapperdata();
  const ::MUTATOR::MapperData& mapperdata() const;
  PROTOBUF_NODISCARD ::MUTATOR::MapperData* release_mapperdata();
  ::MUTATOR::MapperData* mutable_mapperdata();
  void set_allocated_mapperdata(::MUTATOR::MapperData* mapperdata);
  private:
  const ::MUTATOR::MapperData& _internal_mapperdata() const;
  ::MUTATOR::MapperData* _internal_mutable_mapperdata();
  public:
  void unsafe_arena_set_allocated_mapperdata(
      ::MUTATOR::MapperData* mapperdata);
  ::MUTATOR::MapperData* unsafe_arena_release_mapperdata();

  // optional .MUTATOR.LaunchData launchData = 7;
  bool has_launchdata() const;
  private:
  bool _internal_has_launchdata() const;
  public:
  void clear_launchdata();
  const ::MUTATOR::LaunchData& launchdata() const;
  PROTOBUF_NODISCARD ::MUTATOR::LaunchData* release_launchdata();
  ::MUTATOR::LaunchData* mutable_launchdata();
  void set_allocated_launchdata(::MUTATOR::LaunchData* launchdata);
  private:
  const ::MUTATOR::LaunchData& _internal_launchdata() const;
  ::MUTATOR::LaunchData* _internal_mutable_launchdata();
  public:
  void unsafe_arena_set_allocated_launchdata(
      ::MUTATOR::LaunchData* launchdata);
  ::MUTATOR::LaunchData* unsafe_arena_release_launchdata();

  // optional .MUTATOR.CallbackResponse callback = 8;
  bool has_callback() const;
  private:
  bool _internal_has_callback() const;
  public:
  void clear_callback();
  const ::MUTATOR::CallbackResponse& callback() const;
  PROTOBUF_NODISCARD ::MUTATOR::CallbackResponse* release_callback();
  ::MUTATOR::CallbackResponse* mutable_callback();
  void set_allocated_callback(::MUTATOR::CallbackResponse* callback);
  private:
  const ::MUTATOR::CallbackResponse& _internal_callback() const;
  ::MUTATOR::CallbackResponse* _internal_mutable_callback();
  public:
  void unsafe_arena_set_allocated_callback(
      ::MUTATOR::CallbackResponse* callback);
  ::MUTATOR::CallbackResponse* unsafe_arena_release_callback();

  // optional uint32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // optional uint32 status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  uint32_t status() const;
  void set_status(uint32_t value);
  private:
  uint32_t _internal_status() const;
  void _internal_set_status(uint32_t value);
  public:

  // optional uint32 session_id = 4;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint32_t session_id() const;
  void set_session_id(uint32_t value);
  private:
  uint32_t _internal_session_id() const;
  void _internal_set_session_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MUTATOR.ServerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> binaries_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::MUTATOR::MapperData* mapperdata_;
  ::MUTATOR::LaunchData* launchdata_;
  ::MUTATOR::CallbackResponse* callback_;
  uint32_t type_;
  uint32_t status_;
  uint32_t session_id_;
  friend struct ::TableStruct_mutator_2eproto;
};
// -------------------------------------------------------------------

class InstanceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MUTATOR.InstanceRequest) */ {
 public:
  inline InstanceRequest() : InstanceRequest(nullptr) {}
  ~InstanceRequest() override;
  explicit constexpr InstanceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstanceRequest(const InstanceRequest& from);
  InstanceRequest(InstanceRequest&& from) noexcept
    : InstanceRequest() {
    *this = ::std::move(from);
  }

  inline InstanceRequest& operator=(const InstanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceRequest& operator=(InstanceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstanceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstanceRequest* internal_default_instance() {
    return reinterpret_cast<const InstanceRequest*>(
               &_InstanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(InstanceRequest& a, InstanceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstanceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstanceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstanceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstanceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MUTATOR.InstanceRequest";
  }
  protected:
  explicit InstanceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapperFieldNumber = 1,
    kUniqueKeyFieldNumber = 2,
  };
  // optional bool mapper = 1;
  bool has_mapper() const;
  private:
  bool _internal_has_mapper() const;
  public:
  void clear_mapper();
  bool mapper() const;
  void set_mapper(bool value);
  private:
  bool _internal_mapper() const;
  void _internal_set_mapper(bool value);
  public:

  // optional uint32 unique_key = 2;
  bool has_unique_key() const;
  private:
  bool _internal_has_unique_key() const;
  public:
  void clear_unique_key();
  uint32_t unique_key() const;
  void set_unique_key(uint32_t value);
  private:
  uint32_t _internal_unique_key() const;
  void _internal_set_unique_key(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MUTATOR.InstanceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool mapper_;
  uint32_t unique_key_;
  friend struct ::TableStruct_mutator_2eproto;
};
// -------------------------------------------------------------------

class MutatorRequest_ImportsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MutatorRequest_ImportsEntry_DoNotUse, 
    std::string, ::MUTATOR::ImportedModule,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<MutatorRequest_ImportsEntry_DoNotUse, 
    std::string, ::MUTATOR::ImportedModule,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  MutatorRequest_ImportsEntry_DoNotUse();
  explicit constexpr MutatorRequest_ImportsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit MutatorRequest_ImportsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MutatorRequest_ImportsEntry_DoNotUse& other);
  static const MutatorRequest_ImportsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MutatorRequest_ImportsEntry_DoNotUse*>(&_MutatorRequest_ImportsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "MUTATOR.MutatorRequest.ImportsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class MutatorRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MUTATOR.MutatorRequest) */ {
 public:
  inline MutatorRequest() : MutatorRequest(nullptr) {}
  ~MutatorRequest() override;
  explicit constexpr MutatorRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MutatorRequest(const MutatorRequest& from);
  MutatorRequest(MutatorRequest&& from) noexcept
    : MutatorRequest() {
    *this = ::std::move(from);
  }

  inline MutatorRequest& operator=(const MutatorRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutatorRequest& operator=(MutatorRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MutatorRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MutatorRequest* internal_default_instance() {
    return reinterpret_cast<const MutatorRequest*>(
               &_MutatorRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MutatorRequest& a, MutatorRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MutatorRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MutatorRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MutatorRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MutatorRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MutatorRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MutatorRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutatorRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MUTATOR.MutatorRequest";
  }
  protected:
  explicit MutatorRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kBasesFieldNumber = 2,
    kImportsFieldNumber = 3,
    kUniqueKeyFieldNumber = 1,
  };
  // repeated uint64 bases = 2;
  int bases_size() const;
  private:
  int _internal_bases_size() const;
  public:
  void clear_bases();
  private:
  uint64_t _internal_bases(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_bases() const;
  void _internal_add_bases(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_bases();
  public:
  uint64_t bases(int index) const;
  void set_bases(int index, uint64_t value);
  void add_bases(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      bases() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_bases();

  // map<string, .MUTATOR.ImportedModule> imports = 3;
  int imports_size() const;
  private:
  int _internal_imports_size() const;
  public:
  void clear_imports();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >&
      _internal_imports() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >*
      _internal_mutable_imports();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >&
      imports() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >*
      mutable_imports();

  // optional uint32 unique_key = 1;
  bool has_unique_key() const;
  private:
  bool _internal_has_unique_key() const;
  public:
  void clear_unique_key();
  uint32_t unique_key() const;
  void set_unique_key(uint32_t value);
  private:
  uint32_t _internal_unique_key() const;
  void _internal_set_unique_key(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MUTATOR.MutatorRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > bases_;
  mutable std::atomic<int> _bases_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      MutatorRequest_ImportsEntry_DoNotUse,
      std::string, ::MUTATOR::ImportedModule,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> imports_;
  uint32_t unique_key_;
  friend struct ::TableStruct_mutator_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AuthRequest

// string auth_token = 1;
inline void AuthRequest::clear_auth_token() {
  auth_token_.ClearToEmpty();
}
inline const std::string& AuthRequest::auth_token() const {
  // @@protoc_insertion_point(field_get:MUTATOR.AuthRequest.auth_token)
  return _internal_auth_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthRequest::set_auth_token(ArgT0&& arg0, ArgT... args) {
 
 auth_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MUTATOR.AuthRequest.auth_token)
}
inline std::string* AuthRequest::mutable_auth_token() {
  std::string* _s = _internal_mutable_auth_token();
  // @@protoc_insertion_point(field_mutable:MUTATOR.AuthRequest.auth_token)
  return _s;
}
inline const std::string& AuthRequest::_internal_auth_token() const {
  return auth_token_.Get();
}
inline void AuthRequest::_internal_set_auth_token(const std::string& value) {
  
  auth_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthRequest::_internal_mutable_auth_token() {
  
  return auth_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthRequest::release_auth_token() {
  // @@protoc_insertion_point(field_release:MUTATOR.AuthRequest.auth_token)
  return auth_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthRequest::set_allocated_auth_token(std::string* auth_token) {
  if (auth_token != nullptr) {
    
  } else {
    
  }
  auth_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.AuthRequest.auth_token)
}

// -------------------------------------------------------------------

// MutatorSettings

// optional bool shuffle = 1;
inline bool MutatorSettings::_internal_has_shuffle() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MutatorSettings::has_shuffle() const {
  return _internal_has_shuffle();
}
inline void MutatorSettings::clear_shuffle() {
  shuffle_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool MutatorSettings::_internal_shuffle() const {
  return shuffle_;
}
inline bool MutatorSettings::shuffle() const {
  // @@protoc_insertion_point(field_get:MUTATOR.MutatorSettings.shuffle)
  return _internal_shuffle();
}
inline void MutatorSettings::_internal_set_shuffle(bool value) {
  _has_bits_[0] |= 0x00000001u;
  shuffle_ = value;
}
inline void MutatorSettings::set_shuffle(bool value) {
  _internal_set_shuffle(value);
  // @@protoc_insertion_point(field_set:MUTATOR.MutatorSettings.shuffle)
}

// optional bool block_as_object = 2;
inline bool MutatorSettings::_internal_has_block_as_object() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MutatorSettings::has_block_as_object() const {
  return _internal_has_block_as_object();
}
inline void MutatorSettings::clear_block_as_object() {
  block_as_object_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool MutatorSettings::_internal_block_as_object() const {
  return block_as_object_;
}
inline bool MutatorSettings::block_as_object() const {
  // @@protoc_insertion_point(field_get:MUTATOR.MutatorSettings.block_as_object)
  return _internal_block_as_object();
}
inline void MutatorSettings::_internal_set_block_as_object(bool value) {
  _has_bits_[0] |= 0x00000002u;
  block_as_object_ = value;
}
inline void MutatorSettings::set_block_as_object(bool value) {
  _internal_set_block_as_object(value);
  // @@protoc_insertion_point(field_set:MUTATOR.MutatorSettings.block_as_object)
}

// optional bool block_shuffle = 3;
inline bool MutatorSettings::_internal_has_block_shuffle() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MutatorSettings::has_block_shuffle() const {
  return _internal_has_block_shuffle();
}
inline void MutatorSettings::clear_block_shuffle() {
  block_shuffle_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool MutatorSettings::_internal_block_shuffle() const {
  return block_shuffle_;
}
inline bool MutatorSettings::block_shuffle() const {
  // @@protoc_insertion_point(field_get:MUTATOR.MutatorSettings.block_shuffle)
  return _internal_block_shuffle();
}
inline void MutatorSettings::_internal_set_block_shuffle(bool value) {
  _has_bits_[0] |= 0x00000004u;
  block_shuffle_ = value;
}
inline void MutatorSettings::set_block_shuffle(bool value) {
  _internal_set_block_shuffle(value);
  // @@protoc_insertion_point(field_set:MUTATOR.MutatorSettings.block_shuffle)
}

// optional bool obfuscate_rtti = 4;
inline bool MutatorSettings::_internal_has_obfuscate_rtti() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MutatorSettings::has_obfuscate_rtti() const {
  return _internal_has_obfuscate_rtti();
}
inline void MutatorSettings::clear_obfuscate_rtti() {
  obfuscate_rtti_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool MutatorSettings::_internal_obfuscate_rtti() const {
  return obfuscate_rtti_;
}
inline bool MutatorSettings::obfuscate_rtti() const {
  // @@protoc_insertion_point(field_get:MUTATOR.MutatorSettings.obfuscate_rtti)
  return _internal_obfuscate_rtti();
}
inline void MutatorSettings::_internal_set_obfuscate_rtti(bool value) {
  _has_bits_[0] |= 0x00000008u;
  obfuscate_rtti_ = value;
}
inline void MutatorSettings::set_obfuscate_rtti(bool value) {
  _internal_set_obfuscate_rtti(value);
  // @@protoc_insertion_point(field_set:MUTATOR.MutatorSettings.obfuscate_rtti)
}

// optional bool partition = 5;
inline bool MutatorSettings::_internal_has_partition() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MutatorSettings::has_partition() const {
  return _internal_has_partition();
}
inline void MutatorSettings::clear_partition() {
  partition_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool MutatorSettings::_internal_partition() const {
  return partition_;
}
inline bool MutatorSettings::partition() const {
  // @@protoc_insertion_point(field_get:MUTATOR.MutatorSettings.partition)
  return _internal_partition();
}
inline void MutatorSettings::_internal_set_partition(bool value) {
  _has_bits_[0] |= 0x00000010u;
  partition_ = value;
}
inline void MutatorSettings::set_partition(bool value) {
  _internal_set_partition(value);
  // @@protoc_insertion_point(field_set:MUTATOR.MutatorSettings.partition)
}

// optional bool section_randomization = 6;
inline bool MutatorSettings::_internal_has_section_randomization() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MutatorSettings::has_section_randomization() const {
  return _internal_has_section_randomization();
}
inline void MutatorSettings::clear_section_randomization() {
  section_randomization_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool MutatorSettings::_internal_section_randomization() const {
  return section_randomization_;
}
inline bool MutatorSettings::section_randomization() const {
  // @@protoc_insertion_point(field_get:MUTATOR.MutatorSettings.section_randomization)
  return _internal_section_randomization();
}
inline void MutatorSettings::_internal_set_section_randomization(bool value) {
  _has_bits_[0] |= 0x00000020u;
  section_randomization_ = value;
}
inline void MutatorSettings::set_section_randomization(bool value) {
  _internal_set_section_randomization(value);
  // @@protoc_insertion_point(field_set:MUTATOR.MutatorSettings.section_randomization)
}

// optional uint32 min_mutation_length = 7;
inline bool MutatorSettings::_internal_has_min_mutation_length() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MutatorSettings::has_min_mutation_length() const {
  return _internal_has_min_mutation_length();
}
inline void MutatorSettings::clear_min_mutation_length() {
  min_mutation_length_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t MutatorSettings::_internal_min_mutation_length() const {
  return min_mutation_length_;
}
inline uint32_t MutatorSettings::min_mutation_length() const {
  // @@protoc_insertion_point(field_get:MUTATOR.MutatorSettings.min_mutation_length)
  return _internal_min_mutation_length();
}
inline void MutatorSettings::_internal_set_min_mutation_length(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  min_mutation_length_ = value;
}
inline void MutatorSettings::set_min_mutation_length(uint32_t value) {
  _internal_set_min_mutation_length(value);
  // @@protoc_insertion_point(field_set:MUTATOR.MutatorSettings.min_mutation_length)
}

// optional uint32 max_mutation_length = 8;
inline bool MutatorSettings::_internal_has_max_mutation_length() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MutatorSettings::has_max_mutation_length() const {
  return _internal_has_max_mutation_length();
}
inline void MutatorSettings::clear_max_mutation_length() {
  max_mutation_length_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t MutatorSettings::_internal_max_mutation_length() const {
  return max_mutation_length_;
}
inline uint32_t MutatorSettings::max_mutation_length() const {
  // @@protoc_insertion_point(field_get:MUTATOR.MutatorSettings.max_mutation_length)
  return _internal_max_mutation_length();
}
inline void MutatorSettings::_internal_set_max_mutation_length(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  max_mutation_length_ = value;
}
inline void MutatorSettings::set_max_mutation_length(uint32_t value) {
  _internal_set_max_mutation_length(value);
  // @@protoc_insertion_point(field_set:MUTATOR.MutatorSettings.max_mutation_length)
}

// optional .MUTATOR.VM vm_type = 9;
inline bool MutatorSettings::_internal_has_vm_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MutatorSettings::has_vm_type() const {
  return _internal_has_vm_type();
}
inline void MutatorSettings::clear_vm_type() {
  vm_type_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::MUTATOR::VM MutatorSettings::_internal_vm_type() const {
  return static_cast< ::MUTATOR::VM >(vm_type_);
}
inline ::MUTATOR::VM MutatorSettings::vm_type() const {
  // @@protoc_insertion_point(field_get:MUTATOR.MutatorSettings.vm_type)
  return _internal_vm_type();
}
inline void MutatorSettings::_internal_set_vm_type(::MUTATOR::VM value) {
  _has_bits_[0] |= 0x00000100u;
  vm_type_ = value;
}
inline void MutatorSettings::set_vm_type(::MUTATOR::VM value) {
  _internal_set_vm_type(value);
  // @@protoc_insertion_point(field_set:MUTATOR.MutatorSettings.vm_type)
}

// repeated .MUTATOR.Callback callbacks = 10;
inline int MutatorSettings::_internal_callbacks_size() const {
  return callbacks_.size();
}
inline int MutatorSettings::callbacks_size() const {
  return _internal_callbacks_size();
}
inline void MutatorSettings::clear_callbacks() {
  callbacks_.Clear();
}
inline ::MUTATOR::Callback MutatorSettings::_internal_callbacks(int index) const {
  return static_cast< ::MUTATOR::Callback >(callbacks_.Get(index));
}
inline ::MUTATOR::Callback MutatorSettings::callbacks(int index) const {
  // @@protoc_insertion_point(field_get:MUTATOR.MutatorSettings.callbacks)
  return _internal_callbacks(index);
}
inline void MutatorSettings::set_callbacks(int index, ::MUTATOR::Callback value) {
  callbacks_.Set(index, value);
  // @@protoc_insertion_point(field_set:MUTATOR.MutatorSettings.callbacks)
}
inline void MutatorSettings::_internal_add_callbacks(::MUTATOR::Callback value) {
  callbacks_.Add(value);
}
inline void MutatorSettings::add_callbacks(::MUTATOR::Callback value) {
  _internal_add_callbacks(value);
  // @@protoc_insertion_point(field_add:MUTATOR.MutatorSettings.callbacks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
MutatorSettings::callbacks() const {
  // @@protoc_insertion_point(field_list:MUTATOR.MutatorSettings.callbacks)
  return callbacks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MutatorSettings::_internal_mutable_callbacks() {
  return &callbacks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
MutatorSettings::mutable_callbacks() {
  // @@protoc_insertion_point(field_mutable_list:MUTATOR.MutatorSettings.callbacks)
  return _internal_mutable_callbacks();
}

// -------------------------------------------------------------------

// InitializationRequest

// bytes binary = 1;
inline void InitializationRequest::clear_binary() {
  binary_.ClearToEmpty();
}
inline const std::string& InitializationRequest::binary() const {
  // @@protoc_insertion_point(field_get:MUTATOR.InitializationRequest.binary)
  return _internal_binary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitializationRequest::set_binary(ArgT0&& arg0, ArgT... args) {
 
 binary_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MUTATOR.InitializationRequest.binary)
}
inline std::string* InitializationRequest::mutable_binary() {
  std::string* _s = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:MUTATOR.InitializationRequest.binary)
  return _s;
}
inline const std::string& InitializationRequest::_internal_binary() const {
  return binary_.Get();
}
inline void InitializationRequest::_internal_set_binary(const std::string& value) {
  
  binary_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InitializationRequest::_internal_mutable_binary() {
  
  return binary_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InitializationRequest::release_binary() {
  // @@protoc_insertion_point(field_release:MUTATOR.InitializationRequest.binary)
  return binary_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InitializationRequest::set_allocated_binary(std::string* binary) {
  if (binary != nullptr) {
    
  } else {
    
  }
  binary_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), binary,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (binary_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    binary_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.InitializationRequest.binary)
}

// bytes symbols = 2;
inline void InitializationRequest::clear_symbols() {
  symbols_.ClearToEmpty();
}
inline const std::string& InitializationRequest::symbols() const {
  // @@protoc_insertion_point(field_get:MUTATOR.InitializationRequest.symbols)
  return _internal_symbols();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitializationRequest::set_symbols(ArgT0&& arg0, ArgT... args) {
 
 symbols_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MUTATOR.InitializationRequest.symbols)
}
inline std::string* InitializationRequest::mutable_symbols() {
  std::string* _s = _internal_mutable_symbols();
  // @@protoc_insertion_point(field_mutable:MUTATOR.InitializationRequest.symbols)
  return _s;
}
inline const std::string& InitializationRequest::_internal_symbols() const {
  return symbols_.Get();
}
inline void InitializationRequest::_internal_set_symbols(const std::string& value) {
  
  symbols_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InitializationRequest::_internal_mutable_symbols() {
  
  return symbols_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InitializationRequest::release_symbols() {
  // @@protoc_insertion_point(field_release:MUTATOR.InitializationRequest.symbols)
  return symbols_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InitializationRequest::set_allocated_symbols(std::string* symbols) {
  if (symbols != nullptr) {
    
  } else {
    
  }
  symbols_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbols,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (symbols_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    symbols_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.InitializationRequest.symbols)
}

// optional bytes protected_binary = 3;
inline bool InitializationRequest::_internal_has_protected_binary() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InitializationRequest::has_protected_binary() const {
  return _internal_has_protected_binary();
}
inline void InitializationRequest::clear_protected_binary() {
  protected_binary_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InitializationRequest::protected_binary() const {
  // @@protoc_insertion_point(field_get:MUTATOR.InitializationRequest.protected_binary)
  return _internal_protected_binary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitializationRequest::set_protected_binary(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 protected_binary_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MUTATOR.InitializationRequest.protected_binary)
}
inline std::string* InitializationRequest::mutable_protected_binary() {
  std::string* _s = _internal_mutable_protected_binary();
  // @@protoc_insertion_point(field_mutable:MUTATOR.InitializationRequest.protected_binary)
  return _s;
}
inline const std::string& InitializationRequest::_internal_protected_binary() const {
  return protected_binary_.Get();
}
inline void InitializationRequest::_internal_set_protected_binary(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  protected_binary_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InitializationRequest::_internal_mutable_protected_binary() {
  _has_bits_[0] |= 0x00000001u;
  return protected_binary_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InitializationRequest::release_protected_binary() {
  // @@protoc_insertion_point(field_release:MUTATOR.InitializationRequest.protected_binary)
  if (!_internal_has_protected_binary()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = protected_binary_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (protected_binary_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    protected_binary_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InitializationRequest::set_allocated_protected_binary(std::string* protected_binary) {
  if (protected_binary != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  protected_binary_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), protected_binary,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (protected_binary_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    protected_binary_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.InitializationRequest.protected_binary)
}

// optional .MUTATOR.MutatorSettings settings = 4;
inline bool InitializationRequest::_internal_has_settings() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || settings_ != nullptr);
  return value;
}
inline bool InitializationRequest::has_settings() const {
  return _internal_has_settings();
}
inline void InitializationRequest::clear_settings() {
  if (settings_ != nullptr) settings_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::MUTATOR::MutatorSettings& InitializationRequest::_internal_settings() const {
  const ::MUTATOR::MutatorSettings* p = settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::MUTATOR::MutatorSettings&>(
      ::MUTATOR::_MutatorSettings_default_instance_);
}
inline const ::MUTATOR::MutatorSettings& InitializationRequest::settings() const {
  // @@protoc_insertion_point(field_get:MUTATOR.InitializationRequest.settings)
  return _internal_settings();
}
inline void InitializationRequest::unsafe_arena_set_allocated_settings(
    ::MUTATOR::MutatorSettings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(settings_);
  }
  settings_ = settings;
  if (settings) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MUTATOR.InitializationRequest.settings)
}
inline ::MUTATOR::MutatorSettings* InitializationRequest::release_settings() {
  _has_bits_[0] &= ~0x00000002u;
  ::MUTATOR::MutatorSettings* temp = settings_;
  settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MUTATOR::MutatorSettings* InitializationRequest::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:MUTATOR.InitializationRequest.settings)
  _has_bits_[0] &= ~0x00000002u;
  ::MUTATOR::MutatorSettings* temp = settings_;
  settings_ = nullptr;
  return temp;
}
inline ::MUTATOR::MutatorSettings* InitializationRequest::_internal_mutable_settings() {
  _has_bits_[0] |= 0x00000002u;
  if (settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::MUTATOR::MutatorSettings>(GetArenaForAllocation());
    settings_ = p;
  }
  return settings_;
}
inline ::MUTATOR::MutatorSettings* InitializationRequest::mutable_settings() {
  ::MUTATOR::MutatorSettings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:MUTATOR.InitializationRequest.settings)
  return _msg;
}
inline void InitializationRequest::set_allocated_settings(::MUTATOR::MutatorSettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MUTATOR::MutatorSettings>::GetOwningArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.InitializationRequest.settings)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ImportedModule

// map<string, uint64> functions = 2;
inline int ImportedModule::_internal_functions_size() const {
  return functions_.size();
}
inline int ImportedModule::functions_size() const {
  return _internal_functions_size();
}
inline void ImportedModule::clear_functions() {
  functions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
ImportedModule::_internal_functions() const {
  return functions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >&
ImportedModule::functions() const {
  // @@protoc_insertion_point(field_map:MUTATOR.ImportedModule.functions)
  return _internal_functions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
ImportedModule::_internal_mutable_functions() {
  return functions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, uint64_t >*
ImportedModule::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_map:MUTATOR.ImportedModule.functions)
  return _internal_mutable_functions();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MapperData

// repeated uint32 sizes = 1;
inline int MapperData::_internal_sizes_size() const {
  return sizes_.size();
}
inline int MapperData::sizes_size() const {
  return _internal_sizes_size();
}
inline void MapperData::clear_sizes() {
  sizes_.Clear();
}
inline uint32_t MapperData::_internal_sizes(int index) const {
  return sizes_.Get(index);
}
inline uint32_t MapperData::sizes(int index) const {
  // @@protoc_insertion_point(field_get:MUTATOR.MapperData.sizes)
  return _internal_sizes(index);
}
inline void MapperData::set_sizes(int index, uint32_t value) {
  sizes_.Set(index, value);
  // @@protoc_insertion_point(field_set:MUTATOR.MapperData.sizes)
}
inline void MapperData::_internal_add_sizes(uint32_t value) {
  sizes_.Add(value);
}
inline void MapperData::add_sizes(uint32_t value) {
  _internal_add_sizes(value);
  // @@protoc_insertion_point(field_add:MUTATOR.MapperData.sizes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MapperData::_internal_sizes() const {
  return sizes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MapperData::sizes() const {
  // @@protoc_insertion_point(field_list:MUTATOR.MapperData.sizes)
  return _internal_sizes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MapperData::_internal_mutable_sizes() {
  return &sizes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MapperData::mutable_sizes() {
  // @@protoc_insertion_point(field_mutable_list:MUTATOR.MapperData.sizes)
  return _internal_mutable_sizes();
}

// map<string, .MUTATOR.ImportedModule> imports = 2;
inline int MapperData::_internal_imports_size() const {
  return imports_.size();
}
inline int MapperData::imports_size() const {
  return _internal_imports_size();
}
inline void MapperData::clear_imports() {
  imports_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >&
MapperData::_internal_imports() const {
  return imports_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >&
MapperData::imports() const {
  // @@protoc_insertion_point(field_map:MUTATOR.MapperData.imports)
  return _internal_imports();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >*
MapperData::_internal_mutable_imports() {
  return imports_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >*
MapperData::mutable_imports() {
  // @@protoc_insertion_point(field_mutable_map:MUTATOR.MapperData.imports)
  return _internal_mutable_imports();
}

// -------------------------------------------------------------------

// LaunchData

// optional uint64 entry = 1;
inline bool LaunchData::_internal_has_entry() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LaunchData::has_entry() const {
  return _internal_has_entry();
}
inline void LaunchData::clear_entry() {
  entry_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t LaunchData::_internal_entry() const {
  return entry_;
}
inline uint64_t LaunchData::entry() const {
  // @@protoc_insertion_point(field_get:MUTATOR.LaunchData.entry)
  return _internal_entry();
}
inline void LaunchData::_internal_set_entry(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  entry_ = value;
}
inline void LaunchData::set_entry(uint64_t value) {
  _internal_set_entry(value);
  // @@protoc_insertion_point(field_set:MUTATOR.LaunchData.entry)
}

// repeated uint64 callables = 2;
inline int LaunchData::_internal_callables_size() const {
  return callables_.size();
}
inline int LaunchData::callables_size() const {
  return _internal_callables_size();
}
inline void LaunchData::clear_callables() {
  callables_.Clear();
}
inline uint64_t LaunchData::_internal_callables(int index) const {
  return callables_.Get(index);
}
inline uint64_t LaunchData::callables(int index) const {
  // @@protoc_insertion_point(field_get:MUTATOR.LaunchData.callables)
  return _internal_callables(index);
}
inline void LaunchData::set_callables(int index, uint64_t value) {
  callables_.Set(index, value);
  // @@protoc_insertion_point(field_set:MUTATOR.LaunchData.callables)
}
inline void LaunchData::_internal_add_callables(uint64_t value) {
  callables_.Add(value);
}
inline void LaunchData::add_callables(uint64_t value) {
  _internal_add_callables(value);
  // @@protoc_insertion_point(field_add:MUTATOR.LaunchData.callables)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LaunchData::_internal_callables() const {
  return callables_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LaunchData::callables() const {
  // @@protoc_insertion_point(field_list:MUTATOR.LaunchData.callables)
  return _internal_callables();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LaunchData::_internal_mutable_callables() {
  return &callables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LaunchData::mutable_callables() {
  // @@protoc_insertion_point(field_mutable_list:MUTATOR.LaunchData.callables)
  return _internal_mutable_callables();
}

// -------------------------------------------------------------------

// ExportCallback

// optional string name = 1;
inline bool ExportCallback::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExportCallback::has_name() const {
  return _internal_has_name();
}
inline void ExportCallback::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExportCallback::name() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ExportCallback.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportCallback::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MUTATOR.ExportCallback.name)
}
inline std::string* ExportCallback::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:MUTATOR.ExportCallback.name)
  return _s;
}
inline const std::string& ExportCallback::_internal_name() const {
  return name_.Get();
}
inline void ExportCallback::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExportCallback::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExportCallback::release_name() {
  // @@protoc_insertion_point(field_release:MUTATOR.ExportCallback.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExportCallback::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.ExportCallback.name)
}

// optional uint32 size = 2;
inline bool ExportCallback::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExportCallback::has_size() const {
  return _internal_has_size();
}
inline void ExportCallback::clear_size() {
  size_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ExportCallback::_internal_size() const {
  return size_;
}
inline uint32_t ExportCallback::size() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ExportCallback.size)
  return _internal_size();
}
inline void ExportCallback::_internal_set_size(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  size_ = value;
}
inline void ExportCallback::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:MUTATOR.ExportCallback.size)
}

// optional bytes value = 3;
inline bool ExportCallback::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExportCallback::has_value() const {
  return _internal_has_value();
}
inline void ExportCallback::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExportCallback::value() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ExportCallback.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportCallback::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MUTATOR.ExportCallback.value)
}
inline std::string* ExportCallback::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:MUTATOR.ExportCallback.value)
  return _s;
}
inline const std::string& ExportCallback::_internal_value() const {
  return value_.Get();
}
inline void ExportCallback::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExportCallback::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExportCallback::release_value() {
  // @@protoc_insertion_point(field_release:MUTATOR.ExportCallback.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExportCallback::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.ExportCallback.value)
}

// optional bool is_const = 4;
inline bool ExportCallback::_internal_has_is_const() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExportCallback::has_is_const() const {
  return _internal_has_is_const();
}
inline void ExportCallback::clear_is_const() {
  is_const_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ExportCallback::_internal_is_const() const {
  return is_const_;
}
inline bool ExportCallback::is_const() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ExportCallback.is_const)
  return _internal_is_const();
}
inline void ExportCallback::_internal_set_is_const(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_const_ = value;
}
inline void ExportCallback::set_is_const(bool value) {
  _internal_set_is_const(value);
  // @@protoc_insertion_point(field_set:MUTATOR.ExportCallback.is_const)
}

// optional bool is_callable = 5;
inline bool ExportCallback::_internal_has_is_callable() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExportCallback::has_is_callable() const {
  return _internal_has_is_callable();
}
inline void ExportCallback::clear_is_callable() {
  is_callable_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ExportCallback::_internal_is_callable() const {
  return is_callable_;
}
inline bool ExportCallback::is_callable() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ExportCallback.is_callable)
  return _internal_is_callable();
}
inline void ExportCallback::_internal_set_is_callable(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_callable_ = value;
}
inline void ExportCallback::set_is_callable(bool value) {
  _internal_set_is_callable(value);
  // @@protoc_insertion_point(field_set:MUTATOR.ExportCallback.is_callable)
}

// optional uint32 unique_id = 6;
inline bool ExportCallback::_internal_has_unique_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExportCallback::has_unique_id() const {
  return _internal_has_unique_id();
}
inline void ExportCallback::clear_unique_id() {
  unique_id_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ExportCallback::_internal_unique_id() const {
  return unique_id_;
}
inline uint32_t ExportCallback::unique_id() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ExportCallback.unique_id)
  return _internal_unique_id();
}
inline void ExportCallback::_internal_set_unique_id(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  unique_id_ = value;
}
inline void ExportCallback::set_unique_id(uint32_t value) {
  _internal_set_unique_id(value);
  // @@protoc_insertion_point(field_set:MUTATOR.ExportCallback.unique_id)
}

// -------------------------------------------------------------------

// ExpireCallback

// optional uint64 time_left = 1;
inline bool ExpireCallback::_internal_has_time_left() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExpireCallback::has_time_left() const {
  return _internal_has_time_left();
}
inline void ExpireCallback::clear_time_left() {
  time_left_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ExpireCallback::_internal_time_left() const {
  return time_left_;
}
inline uint64_t ExpireCallback::time_left() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ExpireCallback.time_left)
  return _internal_time_left();
}
inline void ExpireCallback::_internal_set_time_left(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  time_left_ = value;
}
inline void ExpireCallback::set_time_left(uint64_t value) {
  _internal_set_time_left(value);
  // @@protoc_insertion_point(field_set:MUTATOR.ExpireCallback.time_left)
}

// -------------------------------------------------------------------

// VersionUpdateCallback

// optional string version = 1;
inline bool VersionUpdateCallback::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VersionUpdateCallback::has_version() const {
  return _internal_has_version();
}
inline void VersionUpdateCallback::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VersionUpdateCallback::version() const {
  // @@protoc_insertion_point(field_get:MUTATOR.VersionUpdateCallback.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VersionUpdateCallback::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MUTATOR.VersionUpdateCallback.version)
}
inline std::string* VersionUpdateCallback::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:MUTATOR.VersionUpdateCallback.version)
  return _s;
}
inline const std::string& VersionUpdateCallback::_internal_version() const {
  return version_.Get();
}
inline void VersionUpdateCallback::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VersionUpdateCallback::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000001u;
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VersionUpdateCallback::release_version() {
  // @@protoc_insertion_point(field_release:MUTATOR.VersionUpdateCallback.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VersionUpdateCallback::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.VersionUpdateCallback.version)
}

// -------------------------------------------------------------------

// CallbackResponse

// optional .MUTATOR.Callback type = 1;
inline bool CallbackResponse::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CallbackResponse::has_type() const {
  return _internal_has_type();
}
inline void CallbackResponse::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::MUTATOR::Callback CallbackResponse::_internal_type() const {
  return static_cast< ::MUTATOR::Callback >(type_);
}
inline ::MUTATOR::Callback CallbackResponse::type() const {
  // @@protoc_insertion_point(field_get:MUTATOR.CallbackResponse.type)
  return _internal_type();
}
inline void CallbackResponse::_internal_set_type(::MUTATOR::Callback value) {
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void CallbackResponse::set_type(::MUTATOR::Callback value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:MUTATOR.CallbackResponse.type)
}

// optional .MUTATOR.ExportCallback export = 2;
inline bool CallbackResponse::_internal_has_export_() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || export__ != nullptr);
  return value;
}
inline bool CallbackResponse::has_export_() const {
  return _internal_has_export_();
}
inline void CallbackResponse::clear_export_() {
  if (export__ != nullptr) export__->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::MUTATOR::ExportCallback& CallbackResponse::_internal_export_() const {
  const ::MUTATOR::ExportCallback* p = export__;
  return p != nullptr ? *p : reinterpret_cast<const ::MUTATOR::ExportCallback&>(
      ::MUTATOR::_ExportCallback_default_instance_);
}
inline const ::MUTATOR::ExportCallback& CallbackResponse::export_() const {
  // @@protoc_insertion_point(field_get:MUTATOR.CallbackResponse.export)
  return _internal_export_();
}
inline void CallbackResponse::unsafe_arena_set_allocated_export_(
    ::MUTATOR::ExportCallback* export_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(export__);
  }
  export__ = export_;
  if (export_) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MUTATOR.CallbackResponse.export)
}
inline ::MUTATOR::ExportCallback* CallbackResponse::release_export_() {
  _has_bits_[0] &= ~0x00000001u;
  ::MUTATOR::ExportCallback* temp = export__;
  export__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MUTATOR::ExportCallback* CallbackResponse::unsafe_arena_release_export_() {
  // @@protoc_insertion_point(field_release:MUTATOR.CallbackResponse.export)
  _has_bits_[0] &= ~0x00000001u;
  ::MUTATOR::ExportCallback* temp = export__;
  export__ = nullptr;
  return temp;
}
inline ::MUTATOR::ExportCallback* CallbackResponse::_internal_mutable_export_() {
  _has_bits_[0] |= 0x00000001u;
  if (export__ == nullptr) {
    auto* p = CreateMaybeMessage<::MUTATOR::ExportCallback>(GetArenaForAllocation());
    export__ = p;
  }
  return export__;
}
inline ::MUTATOR::ExportCallback* CallbackResponse::mutable_export_() {
  ::MUTATOR::ExportCallback* _msg = _internal_mutable_export_();
  // @@protoc_insertion_point(field_mutable:MUTATOR.CallbackResponse.export)
  return _msg;
}
inline void CallbackResponse::set_allocated_export_(::MUTATOR::ExportCallback* export_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete export__;
  }
  if (export_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MUTATOR::ExportCallback>::GetOwningArena(export_);
    if (message_arena != submessage_arena) {
      export_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, export_, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  export__ = export_;
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.CallbackResponse.export)
}

// optional .MUTATOR.ExpireCallback expire = 3;
inline bool CallbackResponse::_internal_has_expire() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || expire_ != nullptr);
  return value;
}
inline bool CallbackResponse::has_expire() const {
  return _internal_has_expire();
}
inline void CallbackResponse::clear_expire() {
  if (expire_ != nullptr) expire_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::MUTATOR::ExpireCallback& CallbackResponse::_internal_expire() const {
  const ::MUTATOR::ExpireCallback* p = expire_;
  return p != nullptr ? *p : reinterpret_cast<const ::MUTATOR::ExpireCallback&>(
      ::MUTATOR::_ExpireCallback_default_instance_);
}
inline const ::MUTATOR::ExpireCallback& CallbackResponse::expire() const {
  // @@protoc_insertion_point(field_get:MUTATOR.CallbackResponse.expire)
  return _internal_expire();
}
inline void CallbackResponse::unsafe_arena_set_allocated_expire(
    ::MUTATOR::ExpireCallback* expire) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expire_);
  }
  expire_ = expire;
  if (expire) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MUTATOR.CallbackResponse.expire)
}
inline ::MUTATOR::ExpireCallback* CallbackResponse::release_expire() {
  _has_bits_[0] &= ~0x00000002u;
  ::MUTATOR::ExpireCallback* temp = expire_;
  expire_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MUTATOR::ExpireCallback* CallbackResponse::unsafe_arena_release_expire() {
  // @@protoc_insertion_point(field_release:MUTATOR.CallbackResponse.expire)
  _has_bits_[0] &= ~0x00000002u;
  ::MUTATOR::ExpireCallback* temp = expire_;
  expire_ = nullptr;
  return temp;
}
inline ::MUTATOR::ExpireCallback* CallbackResponse::_internal_mutable_expire() {
  _has_bits_[0] |= 0x00000002u;
  if (expire_ == nullptr) {
    auto* p = CreateMaybeMessage<::MUTATOR::ExpireCallback>(GetArenaForAllocation());
    expire_ = p;
  }
  return expire_;
}
inline ::MUTATOR::ExpireCallback* CallbackResponse::mutable_expire() {
  ::MUTATOR::ExpireCallback* _msg = _internal_mutable_expire();
  // @@protoc_insertion_point(field_mutable:MUTATOR.CallbackResponse.expire)
  return _msg;
}
inline void CallbackResponse::set_allocated_expire(::MUTATOR::ExpireCallback* expire) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete expire_;
  }
  if (expire) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MUTATOR::ExpireCallback>::GetOwningArena(expire);
    if (message_arena != submessage_arena) {
      expire = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expire, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  expire_ = expire;
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.CallbackResponse.expire)
}

// optional .MUTATOR.VersionUpdateCallback version = 4;
inline bool CallbackResponse::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || version_ != nullptr);
  return value;
}
inline bool CallbackResponse::has_version() const {
  return _internal_has_version();
}
inline void CallbackResponse::clear_version() {
  if (version_ != nullptr) version_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::MUTATOR::VersionUpdateCallback& CallbackResponse::_internal_version() const {
  const ::MUTATOR::VersionUpdateCallback* p = version_;
  return p != nullptr ? *p : reinterpret_cast<const ::MUTATOR::VersionUpdateCallback&>(
      ::MUTATOR::_VersionUpdateCallback_default_instance_);
}
inline const ::MUTATOR::VersionUpdateCallback& CallbackResponse::version() const {
  // @@protoc_insertion_point(field_get:MUTATOR.CallbackResponse.version)
  return _internal_version();
}
inline void CallbackResponse::unsafe_arena_set_allocated_version(
    ::MUTATOR::VersionUpdateCallback* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  version_ = version;
  if (version) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MUTATOR.CallbackResponse.version)
}
inline ::MUTATOR::VersionUpdateCallback* CallbackResponse::release_version() {
  _has_bits_[0] &= ~0x00000004u;
  ::MUTATOR::VersionUpdateCallback* temp = version_;
  version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MUTATOR::VersionUpdateCallback* CallbackResponse::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:MUTATOR.CallbackResponse.version)
  _has_bits_[0] &= ~0x00000004u;
  ::MUTATOR::VersionUpdateCallback* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::MUTATOR::VersionUpdateCallback* CallbackResponse::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000004u;
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::MUTATOR::VersionUpdateCallback>(GetArenaForAllocation());
    version_ = p;
  }
  return version_;
}
inline ::MUTATOR::VersionUpdateCallback* CallbackResponse::mutable_version() {
  ::MUTATOR::VersionUpdateCallback* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:MUTATOR.CallbackResponse.version)
  return _msg;
}
inline void CallbackResponse::set_allocated_version(::MUTATOR::VersionUpdateCallback* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MUTATOR::VersionUpdateCallback>::GetOwningArena(version);
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.CallbackResponse.version)
}

// -------------------------------------------------------------------

// ServerResponse

// optional string token = 1;
inline bool ServerResponse::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServerResponse::has_token() const {
  return _internal_has_token();
}
inline void ServerResponse::clear_token() {
  token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServerResponse::token() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ServerResponse.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerResponse::set_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MUTATOR.ServerResponse.token)
}
inline std::string* ServerResponse::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:MUTATOR.ServerResponse.token)
  return _s;
}
inline const std::string& ServerResponse::_internal_token() const {
  return token_.Get();
}
inline void ServerResponse::_internal_set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerResponse::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerResponse::release_token() {
  // @@protoc_insertion_point(field_release:MUTATOR.ServerResponse.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ServerResponse::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.ServerResponse.token)
}

// optional uint32 type = 2;
inline bool ServerResponse::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ServerResponse::has_type() const {
  return _internal_has_type();
}
inline void ServerResponse::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t ServerResponse::_internal_type() const {
  return type_;
}
inline uint32_t ServerResponse::type() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ServerResponse.type)
  return _internal_type();
}
inline void ServerResponse::_internal_set_type(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  type_ = value;
}
inline void ServerResponse::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:MUTATOR.ServerResponse.type)
}

// optional uint32 status = 3;
inline bool ServerResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ServerResponse::has_status() const {
  return _internal_has_status();
}
inline void ServerResponse::clear_status() {
  status_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ServerResponse::_internal_status() const {
  return status_;
}
inline uint32_t ServerResponse::status() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ServerResponse.status)
  return _internal_status();
}
inline void ServerResponse::_internal_set_status(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  status_ = value;
}
inline void ServerResponse::set_status(uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:MUTATOR.ServerResponse.status)
}

// optional uint32 session_id = 4;
inline bool ServerResponse::_internal_has_session_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ServerResponse::has_session_id() const {
  return _internal_has_session_id();
}
inline void ServerResponse::clear_session_id() {
  session_id_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t ServerResponse::_internal_session_id() const {
  return session_id_;
}
inline uint32_t ServerResponse::session_id() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ServerResponse.session_id)
  return _internal_session_id();
}
inline void ServerResponse::_internal_set_session_id(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  session_id_ = value;
}
inline void ServerResponse::set_session_id(uint32_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:MUTATOR.ServerResponse.session_id)
}

// repeated bytes binaries = 5;
inline int ServerResponse::_internal_binaries_size() const {
  return binaries_.size();
}
inline int ServerResponse::binaries_size() const {
  return _internal_binaries_size();
}
inline void ServerResponse::clear_binaries() {
  binaries_.Clear();
}
inline std::string* ServerResponse::add_binaries() {
  std::string* _s = _internal_add_binaries();
  // @@protoc_insertion_point(field_add_mutable:MUTATOR.ServerResponse.binaries)
  return _s;
}
inline const std::string& ServerResponse::_internal_binaries(int index) const {
  return binaries_.Get(index);
}
inline const std::string& ServerResponse::binaries(int index) const {
  // @@protoc_insertion_point(field_get:MUTATOR.ServerResponse.binaries)
  return _internal_binaries(index);
}
inline std::string* ServerResponse::mutable_binaries(int index) {
  // @@protoc_insertion_point(field_mutable:MUTATOR.ServerResponse.binaries)
  return binaries_.Mutable(index);
}
inline void ServerResponse::set_binaries(int index, const std::string& value) {
  binaries_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:MUTATOR.ServerResponse.binaries)
}
inline void ServerResponse::set_binaries(int index, std::string&& value) {
  binaries_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:MUTATOR.ServerResponse.binaries)
}
inline void ServerResponse::set_binaries(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  binaries_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MUTATOR.ServerResponse.binaries)
}
inline void ServerResponse::set_binaries(int index, const void* value, size_t size) {
  binaries_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MUTATOR.ServerResponse.binaries)
}
inline std::string* ServerResponse::_internal_add_binaries() {
  return binaries_.Add();
}
inline void ServerResponse::add_binaries(const std::string& value) {
  binaries_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MUTATOR.ServerResponse.binaries)
}
inline void ServerResponse::add_binaries(std::string&& value) {
  binaries_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MUTATOR.ServerResponse.binaries)
}
inline void ServerResponse::add_binaries(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  binaries_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MUTATOR.ServerResponse.binaries)
}
inline void ServerResponse::add_binaries(const void* value, size_t size) {
  binaries_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MUTATOR.ServerResponse.binaries)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServerResponse::binaries() const {
  // @@protoc_insertion_point(field_list:MUTATOR.ServerResponse.binaries)
  return binaries_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServerResponse::mutable_binaries() {
  // @@protoc_insertion_point(field_mutable_list:MUTATOR.ServerResponse.binaries)
  return &binaries_;
}

// optional .MUTATOR.MapperData mapperData = 6;
inline bool ServerResponse::_internal_has_mapperdata() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || mapperdata_ != nullptr);
  return value;
}
inline bool ServerResponse::has_mapperdata() const {
  return _internal_has_mapperdata();
}
inline void ServerResponse::clear_mapperdata() {
  if (mapperdata_ != nullptr) mapperdata_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::MUTATOR::MapperData& ServerResponse::_internal_mapperdata() const {
  const ::MUTATOR::MapperData* p = mapperdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::MUTATOR::MapperData&>(
      ::MUTATOR::_MapperData_default_instance_);
}
inline const ::MUTATOR::MapperData& ServerResponse::mapperdata() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ServerResponse.mapperData)
  return _internal_mapperdata();
}
inline void ServerResponse::unsafe_arena_set_allocated_mapperdata(
    ::MUTATOR::MapperData* mapperdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapperdata_);
  }
  mapperdata_ = mapperdata;
  if (mapperdata) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MUTATOR.ServerResponse.mapperData)
}
inline ::MUTATOR::MapperData* ServerResponse::release_mapperdata() {
  _has_bits_[0] &= ~0x00000002u;
  ::MUTATOR::MapperData* temp = mapperdata_;
  mapperdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MUTATOR::MapperData* ServerResponse::unsafe_arena_release_mapperdata() {
  // @@protoc_insertion_point(field_release:MUTATOR.ServerResponse.mapperData)
  _has_bits_[0] &= ~0x00000002u;
  ::MUTATOR::MapperData* temp = mapperdata_;
  mapperdata_ = nullptr;
  return temp;
}
inline ::MUTATOR::MapperData* ServerResponse::_internal_mutable_mapperdata() {
  _has_bits_[0] |= 0x00000002u;
  if (mapperdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::MUTATOR::MapperData>(GetArenaForAllocation());
    mapperdata_ = p;
  }
  return mapperdata_;
}
inline ::MUTATOR::MapperData* ServerResponse::mutable_mapperdata() {
  ::MUTATOR::MapperData* _msg = _internal_mutable_mapperdata();
  // @@protoc_insertion_point(field_mutable:MUTATOR.ServerResponse.mapperData)
  return _msg;
}
inline void ServerResponse::set_allocated_mapperdata(::MUTATOR::MapperData* mapperdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mapperdata_;
  }
  if (mapperdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MUTATOR::MapperData>::GetOwningArena(mapperdata);
    if (message_arena != submessage_arena) {
      mapperdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mapperdata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mapperdata_ = mapperdata;
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.ServerResponse.mapperData)
}

// optional .MUTATOR.LaunchData launchData = 7;
inline bool ServerResponse::_internal_has_launchdata() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || launchdata_ != nullptr);
  return value;
}
inline bool ServerResponse::has_launchdata() const {
  return _internal_has_launchdata();
}
inline void ServerResponse::clear_launchdata() {
  if (launchdata_ != nullptr) launchdata_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::MUTATOR::LaunchData& ServerResponse::_internal_launchdata() const {
  const ::MUTATOR::LaunchData* p = launchdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::MUTATOR::LaunchData&>(
      ::MUTATOR::_LaunchData_default_instance_);
}
inline const ::MUTATOR::LaunchData& ServerResponse::launchdata() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ServerResponse.launchData)
  return _internal_launchdata();
}
inline void ServerResponse::unsafe_arena_set_allocated_launchdata(
    ::MUTATOR::LaunchData* launchdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(launchdata_);
  }
  launchdata_ = launchdata;
  if (launchdata) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MUTATOR.ServerResponse.launchData)
}
inline ::MUTATOR::LaunchData* ServerResponse::release_launchdata() {
  _has_bits_[0] &= ~0x00000004u;
  ::MUTATOR::LaunchData* temp = launchdata_;
  launchdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MUTATOR::LaunchData* ServerResponse::unsafe_arena_release_launchdata() {
  // @@protoc_insertion_point(field_release:MUTATOR.ServerResponse.launchData)
  _has_bits_[0] &= ~0x00000004u;
  ::MUTATOR::LaunchData* temp = launchdata_;
  launchdata_ = nullptr;
  return temp;
}
inline ::MUTATOR::LaunchData* ServerResponse::_internal_mutable_launchdata() {
  _has_bits_[0] |= 0x00000004u;
  if (launchdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::MUTATOR::LaunchData>(GetArenaForAllocation());
    launchdata_ = p;
  }
  return launchdata_;
}
inline ::MUTATOR::LaunchData* ServerResponse::mutable_launchdata() {
  ::MUTATOR::LaunchData* _msg = _internal_mutable_launchdata();
  // @@protoc_insertion_point(field_mutable:MUTATOR.ServerResponse.launchData)
  return _msg;
}
inline void ServerResponse::set_allocated_launchdata(::MUTATOR::LaunchData* launchdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete launchdata_;
  }
  if (launchdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MUTATOR::LaunchData>::GetOwningArena(launchdata);
    if (message_arena != submessage_arena) {
      launchdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, launchdata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  launchdata_ = launchdata;
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.ServerResponse.launchData)
}

// optional .MUTATOR.CallbackResponse callback = 8;
inline bool ServerResponse::_internal_has_callback() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || callback_ != nullptr);
  return value;
}
inline bool ServerResponse::has_callback() const {
  return _internal_has_callback();
}
inline void ServerResponse::clear_callback() {
  if (callback_ != nullptr) callback_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::MUTATOR::CallbackResponse& ServerResponse::_internal_callback() const {
  const ::MUTATOR::CallbackResponse* p = callback_;
  return p != nullptr ? *p : reinterpret_cast<const ::MUTATOR::CallbackResponse&>(
      ::MUTATOR::_CallbackResponse_default_instance_);
}
inline const ::MUTATOR::CallbackResponse& ServerResponse::callback() const {
  // @@protoc_insertion_point(field_get:MUTATOR.ServerResponse.callback)
  return _internal_callback();
}
inline void ServerResponse::unsafe_arena_set_allocated_callback(
    ::MUTATOR::CallbackResponse* callback) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(callback_);
  }
  callback_ = callback;
  if (callback) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MUTATOR.ServerResponse.callback)
}
inline ::MUTATOR::CallbackResponse* ServerResponse::release_callback() {
  _has_bits_[0] &= ~0x00000008u;
  ::MUTATOR::CallbackResponse* temp = callback_;
  callback_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MUTATOR::CallbackResponse* ServerResponse::unsafe_arena_release_callback() {
  // @@protoc_insertion_point(field_release:MUTATOR.ServerResponse.callback)
  _has_bits_[0] &= ~0x00000008u;
  ::MUTATOR::CallbackResponse* temp = callback_;
  callback_ = nullptr;
  return temp;
}
inline ::MUTATOR::CallbackResponse* ServerResponse::_internal_mutable_callback() {
  _has_bits_[0] |= 0x00000008u;
  if (callback_ == nullptr) {
    auto* p = CreateMaybeMessage<::MUTATOR::CallbackResponse>(GetArenaForAllocation());
    callback_ = p;
  }
  return callback_;
}
inline ::MUTATOR::CallbackResponse* ServerResponse::mutable_callback() {
  ::MUTATOR::CallbackResponse* _msg = _internal_mutable_callback();
  // @@protoc_insertion_point(field_mutable:MUTATOR.ServerResponse.callback)
  return _msg;
}
inline void ServerResponse::set_allocated_callback(::MUTATOR::CallbackResponse* callback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete callback_;
  }
  if (callback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MUTATOR::CallbackResponse>::GetOwningArena(callback);
    if (message_arena != submessage_arena) {
      callback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, callback, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  callback_ = callback;
  // @@protoc_insertion_point(field_set_allocated:MUTATOR.ServerResponse.callback)
}

// -------------------------------------------------------------------

// InstanceRequest

// optional bool mapper = 1;
inline bool InstanceRequest::_internal_has_mapper() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstanceRequest::has_mapper() const {
  return _internal_has_mapper();
}
inline void InstanceRequest::clear_mapper() {
  mapper_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool InstanceRequest::_internal_mapper() const {
  return mapper_;
}
inline bool InstanceRequest::mapper() const {
  // @@protoc_insertion_point(field_get:MUTATOR.InstanceRequest.mapper)
  return _internal_mapper();
}
inline void InstanceRequest::_internal_set_mapper(bool value) {
  _has_bits_[0] |= 0x00000001u;
  mapper_ = value;
}
inline void InstanceRequest::set_mapper(bool value) {
  _internal_set_mapper(value);
  // @@protoc_insertion_point(field_set:MUTATOR.InstanceRequest.mapper)
}

// optional uint32 unique_key = 2;
inline bool InstanceRequest::_internal_has_unique_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InstanceRequest::has_unique_key() const {
  return _internal_has_unique_key();
}
inline void InstanceRequest::clear_unique_key() {
  unique_key_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t InstanceRequest::_internal_unique_key() const {
  return unique_key_;
}
inline uint32_t InstanceRequest::unique_key() const {
  // @@protoc_insertion_point(field_get:MUTATOR.InstanceRequest.unique_key)
  return _internal_unique_key();
}
inline void InstanceRequest::_internal_set_unique_key(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  unique_key_ = value;
}
inline void InstanceRequest::set_unique_key(uint32_t value) {
  _internal_set_unique_key(value);
  // @@protoc_insertion_point(field_set:MUTATOR.InstanceRequest.unique_key)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MutatorRequest

// optional uint32 unique_key = 1;
inline bool MutatorRequest::_internal_has_unique_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MutatorRequest::has_unique_key() const {
  return _internal_has_unique_key();
}
inline void MutatorRequest::clear_unique_key() {
  unique_key_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t MutatorRequest::_internal_unique_key() const {
  return unique_key_;
}
inline uint32_t MutatorRequest::unique_key() const {
  // @@protoc_insertion_point(field_get:MUTATOR.MutatorRequest.unique_key)
  return _internal_unique_key();
}
inline void MutatorRequest::_internal_set_unique_key(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  unique_key_ = value;
}
inline void MutatorRequest::set_unique_key(uint32_t value) {
  _internal_set_unique_key(value);
  // @@protoc_insertion_point(field_set:MUTATOR.MutatorRequest.unique_key)
}

// repeated uint64 bases = 2;
inline int MutatorRequest::_internal_bases_size() const {
  return bases_.size();
}
inline int MutatorRequest::bases_size() const {
  return _internal_bases_size();
}
inline void MutatorRequest::clear_bases() {
  bases_.Clear();
}
inline uint64_t MutatorRequest::_internal_bases(int index) const {
  return bases_.Get(index);
}
inline uint64_t MutatorRequest::bases(int index) const {
  // @@protoc_insertion_point(field_get:MUTATOR.MutatorRequest.bases)
  return _internal_bases(index);
}
inline void MutatorRequest::set_bases(int index, uint64_t value) {
  bases_.Set(index, value);
  // @@protoc_insertion_point(field_set:MUTATOR.MutatorRequest.bases)
}
inline void MutatorRequest::_internal_add_bases(uint64_t value) {
  bases_.Add(value);
}
inline void MutatorRequest::add_bases(uint64_t value) {
  _internal_add_bases(value);
  // @@protoc_insertion_point(field_add:MUTATOR.MutatorRequest.bases)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
MutatorRequest::_internal_bases() const {
  return bases_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
MutatorRequest::bases() const {
  // @@protoc_insertion_point(field_list:MUTATOR.MutatorRequest.bases)
  return _internal_bases();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
MutatorRequest::_internal_mutable_bases() {
  return &bases_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
MutatorRequest::mutable_bases() {
  // @@protoc_insertion_point(field_mutable_list:MUTATOR.MutatorRequest.bases)
  return _internal_mutable_bases();
}

// map<string, .MUTATOR.ImportedModule> imports = 3;
inline int MutatorRequest::_internal_imports_size() const {
  return imports_.size();
}
inline int MutatorRequest::imports_size() const {
  return _internal_imports_size();
}
inline void MutatorRequest::clear_imports() {
  imports_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >&
MutatorRequest::_internal_imports() const {
  return imports_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >&
MutatorRequest::imports() const {
  // @@protoc_insertion_point(field_map:MUTATOR.MutatorRequest.imports)
  return _internal_imports();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >*
MutatorRequest::_internal_mutable_imports() {
  return imports_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::MUTATOR::ImportedModule >*
MutatorRequest::mutable_imports() {
  // @@protoc_insertion_point(field_mutable_map:MUTATOR.MutatorRequest.imports)
  return _internal_mutable_imports();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MUTATOR

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MUTATOR::VM> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MUTATOR::VM>() {
  return ::MUTATOR::VM_descriptor();
}
template <> struct is_proto_enum< ::MUTATOR::Callback> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MUTATOR::Callback>() {
  return ::MUTATOR::Callback_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mutator_2eproto
